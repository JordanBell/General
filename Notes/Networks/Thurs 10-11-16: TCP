TCP & UDP

  TCP is very important on the exam
  Provides logical communication

Loads of transport layers have been made, but TCP and UDP are the main workhorses.
TCP is more reliable, but more expensive and difficult to implement.
  Includes congestion control, reducing the load when at high capacity
  Flow control, if one end sends data faster than the other end can process, TCP will slow it down to a speed that the endpoint can deal with
    Like drinking from a firehose
UDP is lightweight, but is inherently unreliable
Neither protocols offer features that are more modern:
  No delay guarantee (I want this data to be received within n seconds, and if you can't do x so that I can handle it)

Network Layer vs Transport Layer
  Network layer allows computers ("hosts" back in the day) to communicate
  Transport layer is communication between processes.

Multiplexing/Demultiplexing
  DM:
    Host receives IP datagrams (16-bit quantities, so far not been an issue)
      Each datagram has source IP, dest IP
      Each carries 1 transport layer segment
      Each segment has source & dest port number
    Host uses IP addresses & port numbers to direct segment to its destination
    [...]

Connection-oriented Demux
  TCP socket identified by 4-tuple
    Source IP
    Source port
    Dest IP
    Dest Port
  Demux: receiver uses all four values to direct segment to appropriate socket
  Server host may support many simultaneous TCP sockets
    Each socket identified by its own 4-tuple
  Web servers have different sockets for each connecting client

Connectionless Demux with UDP
  Different [...]
  Can have two processes reading from the port number
  Sockets waiting on ports
  No splitting apart on the 4-tuple
  (No splitting based on who send it)

UDP used for streaming, DNS, SNMP
  UDP used to be used for skype/voice/video, but this is going out of style
  This was suitable because, if something was lost, we don't want it to catchup, we just want the latest. Otherwise it will be out of order and be no good

UDP Checksums
  Done in 16-bit integers
  [See slides for example]
  Implementation issues
    The design is very 1978.
    Wraparound issues, but can be worked around
      Sum the 16-bit quantities into a 32-but word, then add the top and bottom halves together repeatedly until the top half is 0
    UDP's RFC has loads of details, took until 1988 to publish
    Alledgedly, no UDP implementations worked in the first attempts

Note: "Checksums are rubbish"
  Designed in the 70's for 70's technology
  Merely 2-but flips will not be detected if the distance between them is a multiple of 16
  Need to use a stronger checksum over teh whole thing if the content matters bit for bit (SHA256 is good today - highly unlikely that it will fail to detect an error)

Principles of reliable data transfer
  Need a reliable channel between application and transport layer
    In reality, the transport layer is receiving data from above and is pretending to be reliable. In truth it has algorithms ensuring that it is doing whatever is necessary to make sure it all works.
    Needs substantial buffering to have enough time & data for this to work and be reliable

In a perfect world
  Channels are perfectly reliable
    No errors (ie flipped bits - checksum is used to check this)
    No packet loss
    Packets received by the receiver in order
  No one backs up now because computers are more reliable
  If a channel is perfectly reliable it is sufficient to send a receive data; you don't need any additiaonl mechanisms and acknowledgments

Acknowledgment mechanism
  Need to acknowledge that the packet was received correctly
  (Negative Acknowledgment) Receiver explicitly tells the sender that the packet had errors
  The key problems arise from how to recover from such errors
  This does not handle lost packets, as the received will never know that they were sent.
  The acknowledgments themselves can be corrupted (nightmare!)
    In this case, the sender does not know what happened at the receiver
    One solution is to simply retransmit, BUT you can't simply do that, since you might have duplicates at the receiver
    Can avoid duplicates by enumerating packets, so that ones with the same identifier can be discarded
  Timeouts used when packets lost to/from the receiver, or is delayed out of sequence (beyond the timeout period)
  Latency kills this mechanism
    Speed of light is a limiter (3x10^8 m/s)
    He have paths which are 2x10^6m (here to New York)
    So 20ms round trip assuming infinitely fast routers and computers
    -> 50 packets per second or 600Kb/sec maximum (ropey for video streaming like Youtube)

Pipelined protocols
  Rather than sending one packet at a time, and waiting for ACK before sending the next:
  Send a pipeline of "waiting to be acknowledged" packet stream, later confirming ACK when that is received
  Overview:
    Go-Back-N
      Sender can have up to N unacked packets in pipeline
      Receiver only send cumulative ACK (acknowledges most recent packet in the stream, confirming that it has everything up until that packet)
        Doesn't ack packet if there's a gap
      Sender has timer for older unacked packet
        When timer expires, retransmit all unacked packets
    Selective Repeat (ie "Kermit"):
      Sender can have up to N unack'd packets in pipeline
      rcvr sends individual Ack for each packet
      Sender maintains timer for each unacked packet
        When timer expires, retransmit only that unacked packet
