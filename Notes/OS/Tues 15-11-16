User Threads
  Thread management done by user-level threads library
  Three primary thread libraries
    POSIX Pthreads
    Win32 threads
    Java Threads

Threading Models
  Kernel-space threads are different from user-space threads, so we have several models to map between them
  ie Many user-space threads map to a single kernel thread
    Useful if the kernel does not support threads
    But what if one thread calls a kernel blocking function?
      This will block the whole process (ie all other threads)
      Complex solutions exist where teh user-mode thread package intercepts blocking calls, changes them to non-blocking, and then implements a user-mode blocking mechanism
  Many-to-many
    Maps many user-space threads to multiple kernel space threads (for kernels that support kernel)
  One-to-one (this is what we used for Ex2 during pthread-create)
    When a user-space thread is created, so is a kernel-space thread corresponding to it
  Two-level model (very similar to the thread-pool class in Java)
    Similar to many-to-many, except that it alllows a user thread optionally to be bound directly to a kernel thread
    Examples:
      IRIX
      HP-UX
      Tru64 UNIX
      Solaris 8 and earlier

Semantics of Fork
  [...]
  Depends on the OS implementation

Thread Cancellation
  How to terminate  a thread before it has finished?
  Two general approaches:
    Asynchronous Cancellation terminates the target thread immediately
      We would want to aviod this
        What if a thread acquires a mutex, then the thread gets killed? The lock is never released
      But it's useful as a last resort
    Deferred Cancellation allows the target thread to periodically check if it should be cancelled
      This approach is often cleaner, since the thread can do any and all cleanup processing.

Signal Handling
  Signals notify a process that an event has occurred.
  Signal Handler processes signals:
    Signal is generated by event
    Signal delivered to a process
    Signal is handled by some function
  Not so straightforward for multi-threaded process. Options are:
    Deliver where it applies
    Deliver to every thread
    Deliver to certain threads
    Assign a specific thread to receive all signals for the process
  In most UNIX systems, a thread can be configured to receive

Thread Pools
  These take the load off the processor so it doens't make too many threads, but maintains a maximum number of threads
  Java has a class for this.
    Say number of threads
    First n tasks are assigned to one thread
    When one thread finishes, it is freed up for another task
  Advantages:
    Usually faster to service a request with an existing thread rather that creating a new one
    Allows the number of threads in the application to be bound to the size of the pool, to ensure some level of service for a finite number of clients

Threading Implementation

Thread Libraries
  Thread library provides the programmer with an API for creating and managing threads
  [...](1)

Pthreads
  May be provided either as user-level or kernel-level
  API specifies behavior of the thread libary
  Common on UNIX OS's (Solaris, Linux, Max OSX)

Windows XP threads
  (Apprently not very interesting, so we're skipping the slide)

Linux Threads
  Linux refers to them as tasks rather than threads
  Thread creation is done through clone() system call
  clone() allows a child task to share the address space of the parent task (process) and can be passed flags to control exactly what resources are shared

Java Threads
  Threads are managed by the JVM
  Typically implemented using the threads model provided by unerlying OS
  Java threads created by extending the thread class or implementing the runnable interface
